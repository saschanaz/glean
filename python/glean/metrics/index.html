<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>glean.metrics API documentation</title>
<meta name="description" content="This module contains all of the metric types." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>glean.metrics</code></h1>
</header>
<section id="section-intro">
<p>This module contains all of the metric types.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.


&#34;&#34;&#34;
This module contains all of the metric types.
&#34;&#34;&#34;

# Re-export utilities
from .._uniffi import CommonMetricData
from .._uniffi import Lifetime
from .._uniffi import MemoryUnit
from .._uniffi import TimerId
from .._uniffi import TimeUnit
from .._uniffi import RecordedExperiment

# Re-export some metrics directly
from .._uniffi import BooleanMetric as BooleanMetricType
from .._uniffi import CounterMetric as CounterMetricType
from .._uniffi import MemoryDistributionMetric as MemoryDistributionMetricType
from .._uniffi import QuantityMetric as QuantityMetricType
from .._uniffi import StringListMetric as StringListMetricType

# Export wrapper implementations for metric types
from .datetime import DatetimeMetricType
from .event import EventMetricType, EventExtras, RecordedEvent
from .labeled import (
    LabeledBooleanMetricType,
    LabeledCounterMetricType,
    LabeledStringMetricType,
)
from .ping import PingType
from .string import StringMetricType
from .timespan import TimespanMetricType
from .timing_distribution import TimingDistributionMetricType
from .url import UrlMetricType
from .uuid import UuidMetricType


__all__ = [
    &#34;BooleanMetricType&#34;,
    &#34;CommonMetricData&#34;,
    &#34;CounterMetricType&#34;,
    &#34;DatetimeMetricType&#34;,
    &#34;EventMetricType&#34;,
    &#34;QuantityMetricType&#34;,
    &#34;LabeledBooleanMetricType&#34;,
    &#34;LabeledCounterMetricType&#34;,
    &#34;LabeledStringMetricType&#34;,
    &#34;Lifetime&#34;,
    &#34;MemoryDistributionMetricType&#34;,
    &#34;MemoryUnit&#34;,
    &#34;PingType&#34;,
    &#34;RecordedEvent&#34;,
    &#34;EventExtras&#34;,
    &#34;RecordedExperiment&#34;,
    &#34;StringMetricType&#34;,
    &#34;StringListMetricType&#34;,
    &#34;TimespanMetricType&#34;,
    &#34;TimeUnit&#34;,
    &#34;TimerId&#34;,
    &#34;TimingDistributionMetricType&#34;,
    &#34;UrlMetricType&#34;,
    &#34;UuidMetricType&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="glean.metrics.datetime" href="datetime.html">glean.metrics.datetime</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.event" href="event.html">glean.metrics.event</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.labeled" href="labeled.html">glean.metrics.labeled</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.ping" href="ping.html">glean.metrics.ping</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.string" href="string.html">glean.metrics.string</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.timespan" href="timespan.html">glean.metrics.timespan</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.timing_distribution" href="timing_distribution.html">glean.metrics.timing_distribution</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.url" href="url.html">glean.metrics.url</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.uuid" href="uuid.html">glean.metrics.uuid</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="glean.metrics.BooleanMetric"><code class="flex name class">
<span>class <span class="ident">BooleanMetricType</span></span>
<span>(</span><span>meta)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BooleanMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_1e69_BooleanMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, &#34;_pointer&#34;, None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_1e69_BooleanMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def set(self, value):
        value = bool(value)
        
        rust_call(_UniFFILib.glean_1e69_BooleanMetric_set,self._pointer,
        FfiConverterBool.lower(value))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalBool.lift(
            rust_call(_UniFFILib.glean_1e69_BooleanMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_1e69_BooleanMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.BooleanMetric.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value):
    value = bool(value)
    
    rust_call(_UniFFILib.glean_1e69_BooleanMetric_set,self._pointer,
    FfiConverterBool.lower(value))</code></pre>
</details>
</dd>
<dt id="glean.metrics.BooleanMetric.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error):
    error = error
    
    return FfiConverterInt32.lift(
        rust_call(_UniFFILib.glean_1e69_BooleanMetric_test_get_num_recorded_errors,self._pointer,
    FfiConverterTypeErrorType.lower(error))
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.BooleanMetric.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name=&lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name = DEFAULT):
    if ping_name is DEFAULT:
        ping_name = None
    else:
        ping_name = (None if ping_name is None else ping_name)
    
    return FfiConverterOptionalBool.lift(
        rust_call(_UniFFILib.glean_1e69_BooleanMetric_test_get_value,self._pointer,
    FfiConverterOptionalString.lower(ping_name))
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.CommonMetricData"><code class="flex name class">
<span>class <span class="ident">CommonMetricData</span></span>
<span>(</span><span>category, name, send_in_pings, lifetime, disabled, dynamic_label=&lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommonMetricData:

    def __init__(self, category, name, send_in_pings, lifetime, disabled, dynamic_label = DEFAULT):
        self.category = category
        self.name = name
        self.send_in_pings = send_in_pings
        self.lifetime = lifetime
        self.disabled = disabled
        if dynamic_label is DEFAULT:
            self.dynamic_label = None
        else:
            self.dynamic_label = dynamic_label

    def __str__(self):
        return &#34;CommonMetricData(category={}, name={}, send_in_pings={}, lifetime={}, disabled={}, dynamic_label={})&#34;.format(self.category, self.name, self.send_in_pings, self.lifetime, self.disabled, self.dynamic_label)

    def __eq__(self, other):
        if self.category != other.category:
            return False
        if self.name != other.name:
            return False
        if self.send_in_pings != other.send_in_pings:
            return False
        if self.lifetime != other.lifetime:
            return False
        if self.disabled != other.disabled:
            return False
        if self.dynamic_label != other.dynamic_label:
            return False
        return True</code></pre>
</details>
</dd>
<dt id="glean.metrics.CounterMetric"><code class="flex name class">
<span>class <span class="ident">CounterMetricType</span></span>
<span>(</span><span>meta)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CounterMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_1e69_CounterMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, &#34;_pointer&#34;, None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_1e69_CounterMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def add(self, amount = DEFAULT):
        if amount is DEFAULT:
            amount = 1
        else:
            amount = int(amount)
        
        rust_call(_UniFFILib.glean_1e69_CounterMetric_add,self._pointer,
        FfiConverterInt32.lower(amount))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalInt32.lift(
            rust_call(_UniFFILib.glean_1e69_CounterMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_1e69_CounterMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.CounterMetric.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, amount=&lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, amount = DEFAULT):
    if amount is DEFAULT:
        amount = 1
    else:
        amount = int(amount)
    
    rust_call(_UniFFILib.glean_1e69_CounterMetric_add,self._pointer,
    FfiConverterInt32.lower(amount))</code></pre>
</details>
</dd>
<dt id="glean.metrics.CounterMetric.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error):
    error = error
    
    return FfiConverterInt32.lift(
        rust_call(_UniFFILib.glean_1e69_CounterMetric_test_get_num_recorded_errors,self._pointer,
    FfiConverterTypeErrorType.lower(error))
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.CounterMetric.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name=&lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name = DEFAULT):
    if ping_name is DEFAULT:
        ping_name = None
    else:
        ping_name = (None if ping_name is None else ping_name)
    
    return FfiConverterOptionalInt32.lift(
        rust_call(_UniFFILib.glean_1e69_CounterMetric_test_get_value,self._pointer,
    FfiConverterOptionalString.lower(ping_name))
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.DatetimeMetricType"><code class="flex name class">
<span>class <span class="ident">DatetimeMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.CommonMetricData, time_unit: glean._uniffi.TimeUnit)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording datetime metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The datetime API only exposes the <code><a title="glean.metrics.DatetimeMetricType.set" href="#glean.metrics.DatetimeMetricType.set">DatetimeMetricType.set()</a></code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatetimeMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording datetime metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The datetime API only exposes the `DatetimeMetricType.set` method.
    &#34;&#34;&#34;

    def __init__(self, common_metric_data: CommonMetricData, time_unit: TimeUnit):
        self._inner = DatetimeMetric(common_metric_data, time_unit)

    def set(self, value: Optional[datetime.datetime] = None) -&gt; None:
        &#34;&#34;&#34;
        Set a datetime value, truncating it to the metric&#39;s resolution.

        Args:
            value (datetime.datetime): (default: now) The `datetime.datetime`
                value to set. If not provided, will record the current time.
        &#34;&#34;&#34;
        if value is None:
            # now at UTC -&gt; astimezone gives us a time with the local timezone.
            value = datetime.datetime.now(datetime.timezone.utc).astimezone()

        tzinfo = value.tzinfo
        if tzinfo is not None:
            utcoff = tzinfo.utcoffset(value)
            if utcoff is not None:
                offset = utcoff.seconds
            else:
                offset = 0
        else:
            offset = 0

        dt = Datetime(
            year=value.year,
            month=value.month,
            day=value.day,
            hour=value.hour,
            minute=value.minute,
            second=value.second,
            nanosecond=value.microsecond * 1000,
            offset_seconds=offset,
        )

        self._inner.set(dt)

    def test_get_value_as_str(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only, as an ISO8601 string.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (str): value of the stored metric.
        &#34;&#34;&#34;
        dt = self.test_get_value(ping_name)
        if not dt:
            return None

        return dt.isoformat()

    def test_get_value(
        self, ping_name: Optional[str] = None
    ) -&gt; Optional[datetime.datetime]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (datetime.datetime): value of the stored metric.
        &#34;&#34;&#34;
        dt = self._inner.test_get_value(ping_name)
        if not dt:
            return None

        tz = tzoffset(dt.offset_seconds)
        dt = datetime.datetime(
            year=dt.year,
            month=dt.month,
            day=dt.day,
            hour=dt.hour,
            minute=dt.minute,
            second=dt.second,
            microsecond=round(dt.nanosecond / 1000),
            tzinfo=tz,
        )
        return dt

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.DatetimeMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: Optional[datetime.datetime] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set a datetime value, truncating it to the metric's resolution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>(default: now) The <code>datetime.datetime</code>
value to set. If not provided, will record the current time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: Optional[datetime.datetime] = None) -&gt; None:
    &#34;&#34;&#34;
    Set a datetime value, truncating it to the metric&#39;s resolution.

    Args:
        value (datetime.datetime): (default: now) The `datetime.datetime`
            value to set. If not provided, will record the current time.
    &#34;&#34;&#34;
    if value is None:
        # now at UTC -&gt; astimezone gives us a time with the local timezone.
        value = datetime.datetime.now(datetime.timezone.utc).astimezone()

    tzinfo = value.tzinfo
    if tzinfo is not None:
        utcoff = tzinfo.utcoffset(value)
        if utcoff is not None:
            offset = utcoff.seconds
        else:
            offset = 0
    else:
        offset = 0

    dt = Datetime(
        year=value.year,
        month=value.month,
        day=value.day,
        hour=value.hour,
        minute=value.minute,
        second=value.second,
        nanosecond=value.microsecond * 1000,
        offset_seconds=offset,
    )

    self._inner.set(dt)</code></pre>
</details>
</dd>
<dt id="glean.metrics.DatetimeMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.ErrorType) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
</dd>
<dt id="glean.metrics.DatetimeMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Optional[str] = None) ‑> Optional[datetime.datetime]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (datetime.datetime): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(
    self, ping_name: Optional[str] = None
) -&gt; Optional[datetime.datetime]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (datetime.datetime): value of the stored metric.
    &#34;&#34;&#34;
    dt = self._inner.test_get_value(ping_name)
    if not dt:
        return None

    tz = tzoffset(dt.offset_seconds)
    dt = datetime.datetime(
        year=dt.year,
        month=dt.month,
        day=dt.day,
        hour=dt.hour,
        minute=dt.minute,
        second=dt.second,
        microsecond=round(dt.nanosecond / 1000),
        tzinfo=tz,
    )
    return dt</code></pre>
</details>
</dd>
<dt id="glean.metrics.DatetimeMetricType.test_get_value_as_str"><code class="name flex">
<span>def <span class="ident">test_get_value_as_str</span></span>(<span>self, ping_name: Optional[str] = None) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only, as an ISO8601 string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (str): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value_as_str(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only, as an ISO8601 string.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (str): value of the stored metric.
    &#34;&#34;&#34;
    dt = self.test_get_value(ping_name)
    if not dt:
        return None

    return dt.isoformat()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.EventExtras"><code class="flex name class">
<span>class <span class="ident">EventExtras</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class that can be converted into key-value pairs of event extras.
This will be automatically implemented for event properties of an [EventMetricType].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventExtras:
    &#34;&#34;&#34;
    A class that can be converted into key-value pairs of event extras.
    This will be automatically implemented for event properties of an [EventMetricType].
    &#34;&#34;&#34;

    def to_ffi_extra(self) -&gt; Dict[str, str]:
        &#34;&#34;&#34;
        Convert the event extras into a key-value dict:
        &#34;&#34;&#34;
        return {}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.EventExtras.to_ffi_extra"><code class="name flex">
<span>def <span class="ident">to_ffi_extra</span></span>(<span>self) ‑> Dict[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the event extras into a key-value dict:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_ffi_extra(self) -&gt; Dict[str, str]:
    &#34;&#34;&#34;
    Convert the event extras into a key-value dict:
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.EventMetricType"><code class="flex name class">
<span>class <span class="ident">EventMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.CommonMetricData, allowed_extra_keys: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording events.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The event API only exposes the <code><a title="glean.metrics.EventMetricType.record" href="#glean.metrics.EventMetricType.record">EventMetricType.record()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording events.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The event API only exposes the `EventMetricType.record` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        common_metric_data: CommonMetricData,
        allowed_extra_keys: List[str],
    ):
        self._inner = EventMetric(common_metric_data, allowed_extra_keys)

    def record(
        self, extra: Optional[Union[Dict[str, str], EventExtras]] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Record an event by using the information provided by the instance of
        this class.

        Args:
            extra: optional. The extra keys and values for this event.
                   The maximum length for values is 100.
        &#34;&#34;&#34;

        if isinstance(extra, EventExtras):
            extra = extra.to_ffi_extra()
        elif isinstance(extra, dict):

            def key_to_str(key):
                if isinstance(key, enum.Enum):
                    return key.value
                else:
                    return str(key)

            extra = {key_to_str(k): v for k, v in extra.items()}
        else:
            extra = {}

        self._inner.record(extra)

    def test_get_value(
        self, ping_name: Optional[str] = None
    ) -&gt; Optional[List[RecordedEvent]]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (list of RecordedEventData): value of the stored events.
        &#34;&#34;&#34;
        # Translate NO extras into an empty dictionary,
        # to simplify handling.
        recordings = self._inner.test_get_value(ping_name)
        if recordings:
            for recording in recordings:
                if recording.extra is None:
                    recording.extra = {}

        return recordings

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.EventMetricType.record"><code class="name flex">
<span>def <span class="ident">record</span></span>(<span>self, extra: Union[Dict[str, str], <a title="glean.metrics.event.EventExtras" href="event.html#glean.metrics.event.EventExtras">EventExtras</a>, None] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Record an event by using the information provided by the instance of
this class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extra</code></strong></dt>
<dd>optional. The extra keys and values for this event.
The maximum length for values is 100.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record(
    self, extra: Optional[Union[Dict[str, str], EventExtras]] = None
) -&gt; None:
    &#34;&#34;&#34;
    Record an event by using the information provided by the instance of
    this class.

    Args:
        extra: optional. The extra keys and values for this event.
               The maximum length for values is 100.
    &#34;&#34;&#34;

    if isinstance(extra, EventExtras):
        extra = extra.to_ffi_extra()
    elif isinstance(extra, dict):

        def key_to_str(key):
            if isinstance(key, enum.Enum):
                return key.value
            else:
                return str(key)

        extra = {key_to_str(k): v for k, v in extra.items()}
    else:
        extra = {}

    self._inner.record(extra)</code></pre>
</details>
</dd>
<dt id="glean.metrics.EventMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.ErrorType) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
</dd>
<dt id="glean.metrics.EventMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Optional[str] = None) ‑> Optional[List[glean._uniffi.RecordedEvent]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (list of RecordedEventData): value of the stored events.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(
    self, ping_name: Optional[str] = None
) -&gt; Optional[List[RecordedEvent]]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (list of RecordedEventData): value of the stored events.
    &#34;&#34;&#34;
    # Translate NO extras into an empty dictionary,
    # to simplify handling.
    recordings = self._inner.test_get_value(ping_name)
    if recordings:
        for recording in recordings:
            if recording.extra is None:
                recording.extra = {}

    return recordings</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.LabeledBooleanMetricType"><code class="flex name class">
<span>class <span class="ident">LabeledBooleanMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.CommonMetricData, labels: Optional[Set[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer-facing API for labeled metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>Unlike most metric types, LabeledMetricType does not have its own
corresponding storage, but records metrics for the underlying metric type T
in the storage for that type. The only difference is that labeled metrics
are stored with the special key <code>$category.$name/$label</code>. The collect
method knows how to pull these special values back out of the individual
metric storage and rearrange them correctly in the ping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledBooleanMetricType(LabeledMetricBase):
    _ctor = LabeledBoolean</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>glean.metrics.labeled.LabeledMetricBase</li>
</ul>
</dd>
<dt id="glean.metrics.LabeledCounterMetricType"><code class="flex name class">
<span>class <span class="ident">LabeledCounterMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.CommonMetricData, labels: Optional[Set[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer-facing API for labeled metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>Unlike most metric types, LabeledMetricType does not have its own
corresponding storage, but records metrics for the underlying metric type T
in the storage for that type. The only difference is that labeled metrics
are stored with the special key <code>$category.$name/$label</code>. The collect
method knows how to pull these special values back out of the individual
metric storage and rearrange them correctly in the ping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledCounterMetricType(LabeledMetricBase):
    _ctor = LabeledCounter</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>glean.metrics.labeled.LabeledMetricBase</li>
</ul>
</dd>
<dt id="glean.metrics.LabeledStringMetricType"><code class="flex name class">
<span>class <span class="ident">LabeledStringMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.CommonMetricData, labels: Optional[Set[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer-facing API for labeled metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>Unlike most metric types, LabeledMetricType does not have its own
corresponding storage, but records metrics for the underlying metric type T
in the storage for that type. The only difference is that labeled metrics
are stored with the special key <code>$category.$name/$label</code>. The collect
method knows how to pull these special values back out of the individual
metric storage and rearrange them correctly in the ping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledStringMetricType(LabeledMetricBase):
    _ctor = LabeledString</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>glean.metrics.labeled.LabeledMetricBase</li>
</ul>
</dd>
<dt id="glean.metrics.Lifetime"><code class="flex name class">
<span>class <span class="ident">Lifetime</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lifetime(enum.Enum):
    PING = 1
    APPLICATION = 2
    USER = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.Lifetime.APPLICATION"><code class="name">var <span class="ident">APPLICATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.Lifetime.PING"><code class="name">var <span class="ident">PING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.Lifetime.USER"><code class="name">var <span class="ident">USER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.MemoryDistributionMetric"><code class="flex name class">
<span>class <span class="ident">MemoryDistributionMetricType</span></span>
<span>(</span><span>meta, memory_unit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryDistributionMetric(object):
    def __init__(self, meta,memory_unit):
        meta = meta
        
        memory_unit = memory_unit
        
        self._pointer = rust_call(_UniFFILib.glean_1e69_MemoryDistributionMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterTypeMemoryUnit.lower(memory_unit))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, &#34;_pointer&#34;, None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_1e69_MemoryDistributionMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def accumulate(self, sample):
        sample = int(sample)
        
        rust_call(_UniFFILib.glean_1e69_MemoryDistributionMetric_accumulate,self._pointer,
        FfiConverterInt64.lower(sample))
    
    def accumulate_samples(self, samples):
        samples = list(int(x) for x in samples)
        
        rust_call(_UniFFILib.glean_1e69_MemoryDistributionMetric_accumulate_samples,self._pointer,
        FfiConverterSequenceInt64.lower(samples))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalTypeDistributionData.lift(
            rust_call(_UniFFILib.glean_1e69_MemoryDistributionMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_1e69_MemoryDistributionMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.MemoryDistributionMetric.accumulate"><code class="name flex">
<span>def <span class="ident">accumulate</span></span>(<span>self, sample)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accumulate(self, sample):
    sample = int(sample)
    
    rust_call(_UniFFILib.glean_1e69_MemoryDistributionMetric_accumulate,self._pointer,
    FfiConverterInt64.lower(sample))</code></pre>
</details>
</dd>
<dt id="glean.metrics.MemoryDistributionMetric.accumulate_samples"><code class="name flex">
<span>def <span class="ident">accumulate_samples</span></span>(<span>self, samples)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accumulate_samples(self, samples):
    samples = list(int(x) for x in samples)
    
    rust_call(_UniFFILib.glean_1e69_MemoryDistributionMetric_accumulate_samples,self._pointer,
    FfiConverterSequenceInt64.lower(samples))</code></pre>
</details>
</dd>
<dt id="glean.metrics.MemoryDistributionMetric.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error):
    error = error
    
    return FfiConverterInt32.lift(
        rust_call(_UniFFILib.glean_1e69_MemoryDistributionMetric_test_get_num_recorded_errors,self._pointer,
    FfiConverterTypeErrorType.lower(error))
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.MemoryDistributionMetric.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name=&lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name = DEFAULT):
    if ping_name is DEFAULT:
        ping_name = None
    else:
        ping_name = (None if ping_name is None else ping_name)
    
    return FfiConverterOptionalTypeDistributionData.lift(
        rust_call(_UniFFILib.glean_1e69_MemoryDistributionMetric_test_get_value,self._pointer,
    FfiConverterOptionalString.lower(ping_name))
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.MemoryUnit"><code class="flex name class">
<span>class <span class="ident">MemoryUnit</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryUnit(enum.Enum):
    BYTE = 1
    KILOBYTE = 2
    MEGABYTE = 3
    GIGABYTE = 4</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.MemoryUnit.BYTE"><code class="name">var <span class="ident">BYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.MemoryUnit.GIGABYTE"><code class="name">var <span class="ident">GIGABYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.MemoryUnit.KILOBYTE"><code class="name">var <span class="ident">KILOBYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.MemoryUnit.MEGABYTE"><code class="name">var <span class="ident">MEGABYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.PingType"><code class="flex name class">
<span>class <span class="ident">PingType</span></span>
<span>(</span><span>name: str, include_client_id: bool, send_if_empty: bool, reason_codes: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for custom pings.</p>
<p>The Ping API only exposes the <code><a title="glean.metrics.PingType.submit" href="#glean.metrics.PingType.submit">PingType.submit()</a></code> method, which schedules a
ping for eventual uploading.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PingType:
    def __init__(
        self,
        name: str,
        include_client_id: bool,
        send_if_empty: bool,
        reason_codes: List[str],
    ):
        &#34;&#34;&#34;
        This implements the developer facing API for custom pings.

        The Ping API only exposes the `PingType.submit` method, which schedules a
        ping for eventual uploading.
        &#34;&#34;&#34;
        self._reason_codes = reason_codes
        self._inner = GleanPingType(
            name, include_client_id, send_if_empty, reason_codes
        )
        self._test_callback = None  # type: Optional[Callable[[Optional[str]], None]]

    def test_before_next_submit(self, cb: Callable[[Optional[str]], None]):
        &#34;&#34;&#34;
        **Test-only API**

        Attach a callback to be called right before a new ping is submitted.
        The provided function is called exactly once before submitting a ping.

        Note: The callback will be called on any call to submit.
        A ping might not be sent afterwards, e.g. if the ping is otherwise empty (and
        `send_if_empty` is `False`).
        &#34;&#34;&#34;
        self._test_callback = cb

    def submit(self, reason: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Collect and submit the ping for eventual uploading.

        If the ping currently contains no content, it will not be sent.

        Args:
            reason (enum, optional): The reason the ping was submitted.
        &#34;&#34;&#34;
        reason_string: Optional[str] = None
        if reason is not None:
            reason_string = self._reason_codes[reason]
        else:
            reason_string = None

        if self._test_callback is not None:
            self._test_callback(reason_string)
            self._test_callback = None

        self._inner.submit(reason_string)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.PingType.submit"><code class="name flex">
<span>def <span class="ident">submit</span></span>(<span>self, reason: Optional[int] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Collect and submit the ping for eventual uploading.</p>
<p>If the ping currently contains no content, it will not be sent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code>enum</code>, optional</dt>
<dd>The reason the ping was submitted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit(self, reason: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Collect and submit the ping for eventual uploading.

    If the ping currently contains no content, it will not be sent.

    Args:
        reason (enum, optional): The reason the ping was submitted.
    &#34;&#34;&#34;
    reason_string: Optional[str] = None
    if reason is not None:
        reason_string = self._reason_codes[reason]
    else:
        reason_string = None

    if self._test_callback is not None:
        self._test_callback(reason_string)
        self._test_callback = None

    self._inner.submit(reason_string)</code></pre>
</details>
</dd>
<dt id="glean.metrics.PingType.test_before_next_submit"><code class="name flex">
<span>def <span class="ident">test_before_next_submit</span></span>(<span>self, cb: Callable[[Optional[str]], None])</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Test-only API</strong></p>
<p>Attach a callback to be called right before a new ping is submitted.
The provided function is called exactly once before submitting a ping.</p>
<p>Note: The callback will be called on any call to submit.
A ping might not be sent afterwards, e.g. if the ping is otherwise empty (and
<code>send_if_empty</code> is <code>False</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_before_next_submit(self, cb: Callable[[Optional[str]], None]):
    &#34;&#34;&#34;
    **Test-only API**

    Attach a callback to be called right before a new ping is submitted.
    The provided function is called exactly once before submitting a ping.

    Note: The callback will be called on any call to submit.
    A ping might not be sent afterwards, e.g. if the ping is otherwise empty (and
    `send_if_empty` is `False`).
    &#34;&#34;&#34;
    self._test_callback = cb</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.QuantityMetric"><code class="flex name class">
<span>class <span class="ident">QuantityMetricType</span></span>
<span>(</span><span>meta)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuantityMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_1e69_QuantityMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, &#34;_pointer&#34;, None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_1e69_QuantityMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def set(self, value):
        value = int(value)
        
        rust_call(_UniFFILib.glean_1e69_QuantityMetric_set,self._pointer,
        FfiConverterInt64.lower(value))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalInt64.lift(
            rust_call(_UniFFILib.glean_1e69_QuantityMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_1e69_QuantityMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.QuantityMetric.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value):
    value = int(value)
    
    rust_call(_UniFFILib.glean_1e69_QuantityMetric_set,self._pointer,
    FfiConverterInt64.lower(value))</code></pre>
</details>
</dd>
<dt id="glean.metrics.QuantityMetric.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error):
    error = error
    
    return FfiConverterInt32.lift(
        rust_call(_UniFFILib.glean_1e69_QuantityMetric_test_get_num_recorded_errors,self._pointer,
    FfiConverterTypeErrorType.lower(error))
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.QuantityMetric.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name=&lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name = DEFAULT):
    if ping_name is DEFAULT:
        ping_name = None
    else:
        ping_name = (None if ping_name is None else ping_name)
    
    return FfiConverterOptionalInt64.lift(
        rust_call(_UniFFILib.glean_1e69_QuantityMetric_test_get_value,self._pointer,
    FfiConverterOptionalString.lower(ping_name))
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.RecordedEvent"><code class="flex name class">
<span>class <span class="ident">RecordedEvent</span></span>
<span>(</span><span>timestamp, category, name, extra)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecordedEvent:

    def __init__(self, timestamp, category, name, extra):
        self.timestamp = timestamp
        self.category = category
        self.name = name
        self.extra = extra

    def __str__(self):
        return &#34;RecordedEvent(timestamp={}, category={}, name={}, extra={})&#34;.format(self.timestamp, self.category, self.name, self.extra)

    def __eq__(self, other):
        if self.timestamp != other.timestamp:
            return False
        if self.category != other.category:
            return False
        if self.name != other.name:
            return False
        if self.extra != other.extra:
            return False
        return True</code></pre>
</details>
</dd>
<dt id="glean.metrics.RecordedExperiment"><code class="flex name class">
<span>class <span class="ident">RecordedExperiment</span></span>
<span>(</span><span>branch, extra)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecordedExperiment:

    def __init__(self, branch, extra):
        self.branch = branch
        self.extra = extra

    def __str__(self):
        return &#34;RecordedExperiment(branch={}, extra={})&#34;.format(self.branch, self.extra)

    def __eq__(self, other):
        if self.branch != other.branch:
            return False
        if self.extra != other.extra:
            return False
        return True</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringListMetric"><code class="flex name class">
<span>class <span class="ident">StringListMetricType</span></span>
<span>(</span><span>meta)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringListMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_1e69_StringListMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, &#34;_pointer&#34;, None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_1e69_StringListMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def add(self, value):
        value = value
        
        rust_call(_UniFFILib.glean_1e69_StringListMetric_add,self._pointer,
        FfiConverterString.lower(value))
    
    def set(self, value):
        value = list(x for x in value)
        
        rust_call(_UniFFILib.glean_1e69_StringListMetric_set,self._pointer,
        FfiConverterSequenceString.lower(value))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalSequenceString.lift(
            rust_call(_UniFFILib.glean_1e69_StringListMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_1e69_StringListMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.StringListMetric.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, value):
    value = value
    
    rust_call(_UniFFILib.glean_1e69_StringListMetric_add,self._pointer,
    FfiConverterString.lower(value))</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringListMetric.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value):
    value = list(x for x in value)
    
    rust_call(_UniFFILib.glean_1e69_StringListMetric_set,self._pointer,
    FfiConverterSequenceString.lower(value))</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringListMetric.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error):
    error = error
    
    return FfiConverterInt32.lift(
        rust_call(_UniFFILib.glean_1e69_StringListMetric_test_get_num_recorded_errors,self._pointer,
    FfiConverterTypeErrorType.lower(error))
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringListMetric.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name=&lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name = DEFAULT):
    if ping_name is DEFAULT:
        ping_name = None
    else:
        ping_name = (None if ping_name is None else ping_name)
    
    return FfiConverterOptionalSequenceString.lift(
        rust_call(_UniFFILib.glean_1e69_StringListMetric_test_get_value,self._pointer,
    FfiConverterOptionalString.lower(ping_name))
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.StringMetricType"><code class="flex name class">
<span>class <span class="ident">StringMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.CommonMetricData)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording string metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The string API only exposes the <code><a title="glean.metrics.StringMetricType.set" href="#glean.metrics.StringMetricType.set">StringMetricType.set()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording string metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The string API only exposes the `StringMetricType.set` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(self, common_metric_data: CommonMetricData):
        self._inner = StringMetric(common_metric_data)

    def set(self, value: str) -&gt; None:
        &#34;&#34;&#34;
        Set a string value.

        Args:
            value (str): This is a user-defined string value. If the length of
                the string exceeds the maximum length, it will be truncated.
        &#34;&#34;&#34;
        if value is None:
            return

        self._inner.set(value)

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
        return self._inner.test_get_value(ping_name)

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.StringMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set a string value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>This is a user-defined string value. If the length of
the string exceeds the maximum length, it will be truncated.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: str) -&gt; None:
    &#34;&#34;&#34;
    Set a string value.

    Args:
        value (str): This is a user-defined string value. If the length of
            the string exceeds the maximum length, it will be truncated.
    &#34;&#34;&#34;
    if value is None:
        return

    self._inner.set(value)</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.ErrorType) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Optional[str] = None) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
    return self._inner.test_get_value(ping_name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.TimeUnit"><code class="flex name class">
<span>class <span class="ident">TimeUnit</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeUnit(enum.Enum):
    NANOSECOND = 1
    MICROSECOND = 2
    MILLISECOND = 3
    SECOND = 4
    MINUTE = 5
    HOUR = 6
    DAY = 7</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.TimeUnit.DAY"><code class="name">var <span class="ident">DAY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.HOUR"><code class="name">var <span class="ident">HOUR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.MICROSECOND"><code class="name">var <span class="ident">MICROSECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.MILLISECOND"><code class="name">var <span class="ident">MILLISECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.MINUTE"><code class="name">var <span class="ident">MINUTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.NANOSECOND"><code class="name">var <span class="ident">NANOSECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="glean.metrics.TimeUnit.SECOND"><code class="name">var <span class="ident">SECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.TimerId"><code class="flex name class">
<span>class <span class="ident">TimerId</span></span>
<span>(</span><span>id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimerId:

    def __init__(self, id):
        self.id = id

    def __str__(self):
        return &#34;TimerId(id={})&#34;.format(self.id)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        return True</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType"><code class="flex name class">
<span>class <span class="ident">TimespanMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.CommonMetricData, time_unit: glean._uniffi.TimeUnit)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording timespan metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The timespan API exposes the <code><a title="glean.metrics.TimespanMetricType.start" href="#glean.metrics.TimespanMetricType.start">TimespanMetricType.start()</a></code>,
<code><a title="glean.metrics.TimespanMetricType.stop" href="#glean.metrics.TimespanMetricType.stop">TimespanMetricType.stop()</a></code> and <code><a title="glean.metrics.TimespanMetricType.cancel" href="#glean.metrics.TimespanMetricType.cancel">TimespanMetricType.cancel()</a></code> methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimespanMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording timespan metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The timespan API exposes the `TimespanMetricType.start`,
    `TimespanMetricType.stop` and `TimespanMetricType.cancel` methods.
    &#34;&#34;&#34;

    def __init__(
        self,
        common_metric_data: CommonMetricData,
        time_unit: TimeUnit,
    ):
        self._inner = TimespanMetric(common_metric_data, time_unit)

    def start(self) -&gt; None:
        &#34;&#34;&#34;
        Start tracking time for the provided metric.

        This records an error if it’s already tracking time (i.e. `start` was
        already called with no corresponding `stop`): in that case the original
        start time will be preserved.
        &#34;&#34;&#34;
        self._inner.start()

    def stop(self) -&gt; None:
        &#34;&#34;&#34;
        Stop tracking time for the provided metric.

        Sets the metric to the elapsed time, but does not overwrite an already
        existing value.
        This will record an error if no `start` was called or there is an already
        existing value.
        &#34;&#34;&#34;
        self._inner.stop()

    def cancel(self) -&gt; None:
        &#34;&#34;&#34;
        Abort a previous `start` call. No error is recorded if no `start` was called.
        &#34;&#34;&#34;
        self._inner.cancel()

    class _TimespanContextManager:
        &#34;&#34;&#34;
        A context manager for recording timings. Used by the `measure` method.
        &#34;&#34;&#34;

        def __init__(self, timespan: &#34;TimespanMetricType&#34;):
            self._timespan = timespan

        def __enter__(self) -&gt; None:
            self._timespan.start()

        def __exit__(self, type, value, tb) -&gt; None:
            if tb is None:
                self._timespan.stop()
            else:
                self._timespan.cancel()

    def measure(self) -&gt; &#34;_TimespanContextManager&#34;:
        &#34;&#34;&#34;
        Provides a context manager for measuring the time it takes to execute
        snippets of code in a `with` statement.

        If the contents of the `with` statement raise an exception, the timing
        is not recorded.

        Usage:
            with metrics.perf.timer.measure():
                # ... do something that takes time ...
        &#34;&#34;&#34;
        return self._TimespanContextManager(self)

    def set_raw_nanos(self, elapsed_nanos: int) -&gt; None:
        &#34;&#34;&#34;
        Explicitly set the timespan value, in nanoseconds.

        This API should only be used if your library or application requires recording
        times in a way that can not make use of [start]/[stop]/[cancel].

        [setRawNanos] does not overwrite a running timer or an already existing value.

        Args:
            elapsed_nanos (int): The elapsed time to record, in nanoseconds.
        &#34;&#34;&#34;
        self._inner.set_raw_nanos(elapsed_nanos)

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (bool): value of the stored metric.
        &#34;&#34;&#34;
        return self._inner.test_get_value(ping_name)

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.TimespanMetricType.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Abort a previous <code>start</code> call. No error is recorded if no <code>start</code> was called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self) -&gt; None:
    &#34;&#34;&#34;
    Abort a previous `start` call. No error is recorded if no `start` was called.
    &#34;&#34;&#34;
    self._inner.cancel()</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.measure"><code class="name flex">
<span>def <span class="ident">measure</span></span>(<span>self) ‑> _TimespanContextManager</span>
</code></dt>
<dd>
<div class="desc"><p>Provides a context manager for measuring the time it takes to execute
snippets of code in a <code>with</code> statement.</p>
<p>If the contents of the <code>with</code> statement raise an exception, the timing
is not recorded.</p>
<h2 id="usage">Usage</h2>
<p>with metrics.perf.timer.measure():
# &hellip; do something that takes time &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def measure(self) -&gt; &#34;_TimespanContextManager&#34;:
    &#34;&#34;&#34;
    Provides a context manager for measuring the time it takes to execute
    snippets of code in a `with` statement.

    If the contents of the `with` statement raise an exception, the timing
    is not recorded.

    Usage:
        with metrics.perf.timer.measure():
            # ... do something that takes time ...
    &#34;&#34;&#34;
    return self._TimespanContextManager(self)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.set_raw_nanos"><code class="name flex">
<span>def <span class="ident">set_raw_nanos</span></span>(<span>self, elapsed_nanos: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Explicitly set the timespan value, in nanoseconds.</p>
<p>This API should only be used if your library or application requires recording
times in a way that can not make use of [start]/[stop]/[cancel].</p>
<p>[setRawNanos] does not overwrite a running timer or an already existing value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elapsed_nanos</code></strong> :&ensp;<code>int</code></dt>
<dd>The elapsed time to record, in nanoseconds.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_raw_nanos(self, elapsed_nanos: int) -&gt; None:
    &#34;&#34;&#34;
    Explicitly set the timespan value, in nanoseconds.

    This API should only be used if your library or application requires recording
    times in a way that can not make use of [start]/[stop]/[cancel].

    [setRawNanos] does not overwrite a running timer or an already existing value.

    Args:
        elapsed_nanos (int): The elapsed time to record, in nanoseconds.
    &#34;&#34;&#34;
    self._inner.set_raw_nanos(elapsed_nanos)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Start tracking time for the provided metric.</p>
<p>This records an error if it’s already tracking time (i.e. <code>start</code> was
already called with no corresponding <code>stop</code>): in that case the original
start time will be preserved.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; None:
    &#34;&#34;&#34;
    Start tracking time for the provided metric.

    This records an error if it’s already tracking time (i.e. `start` was
    already called with no corresponding `stop`): in that case the original
    start time will be preserved.
    &#34;&#34;&#34;
    self._inner.start()</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Stop tracking time for the provided metric.</p>
<p>Sets the metric to the elapsed time, but does not overwrite an already
existing value.
This will record an error if no <code>start</code> was called or there is an already
existing value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self) -&gt; None:
    &#34;&#34;&#34;
    Stop tracking time for the provided metric.

    Sets the metric to the elapsed time, but does not overwrite an already
    existing value.
    This will record an error if no `start` was called or there is an already
    existing value.
    &#34;&#34;&#34;
    self._inner.stop()</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.ErrorType) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Optional[str] = None) ‑> Optional[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (bool): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[int]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (bool): value of the stored metric.
    &#34;&#34;&#34;
    return self._inner.test_get_value(ping_name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType"><code class="flex name class">
<span>class <span class="ident">TimingDistributionMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.CommonMetricData, time_unit: glean._uniffi.TimeUnit)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording timing distribution
metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimingDistributionMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording timing distribution
    metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.
    &#34;&#34;&#34;

    def __init__(
        self,
        common_metric_data: CommonMetricData,
        time_unit: TimeUnit,
    ):
        self._inner = TimingDistributionMetric(common_metric_data, time_unit)

    def start(self) -&gt; TimerId:
        &#34;&#34;&#34;
        Start tracking time for the provided metric.
        Multiple timers can run simultaneously.

        Returns:
            timer_id: The object to associate with this timing.
        &#34;&#34;&#34;
        return self._inner.start()

    def stop_and_accumulate(self, timer_id: TimerId) -&gt; None:
        &#34;&#34;&#34;
        Stop tracking time for the provided metric and associated timer id. Add a
        count to the corresponding bucket in the timing distribution.
        This will record an error if no `start` was called.

        Args:
            timer_id: The timer id associated with this timing. This allows for
                concurrent timing of events associated with different ids to
                the same timespan metric.
        &#34;&#34;&#34;
        self._inner.stop_and_accumulate(timer_id)

    def cancel(self, timer_id: TimerId) -&gt; None:
        &#34;&#34;&#34;
        Abort a previous `start` call. No error is recorded if no `start` was called.

        Args:
            timer_id: The timer id associated with this timing. This allows for
                concurrent timing of events associated with different ids to
                the same timing distribution metric.
        &#34;&#34;&#34;
        self._inner.cancel(timer_id)

    class _TimingDistributionContextManager:
        &#34;&#34;&#34;
        A context manager for recording timings. Used by the `measure` method.
        &#34;&#34;&#34;

        def __init__(self, timing_distribution: &#34;TimingDistributionMetricType&#34;):
            self._timing_distribution = timing_distribution

        def __enter__(self) -&gt; None:
            self._timer_id = self._timing_distribution.start()

        def __exit__(self, type, value, tb) -&gt; None:
            if tb is None:
                self._timing_distribution.stop_and_accumulate(self._timer_id)
            else:
                self._timing_distribution.cancel(self._timer_id)

    def measure(self) -&gt; &#34;_TimingDistributionContextManager&#34;:
        &#34;&#34;&#34;
        Provides a context manager for measuring the time it takes to execute
        snippets of code in a `with` statement.

        If the contents of the `with` statement raise an exception, the timing
        is not recorded.

        Usage:
            with metrics.perf.timer.measure():
                # ... do something that takes time ...
        &#34;&#34;&#34;
        return self._TimingDistributionContextManager(self)

    def test_get_value(
        self, ping_name: Optional[str] = None
    ) -&gt; Optional[DistributionData]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (DistriubutionData): value of the stored metric.
        &#34;&#34;&#34;
        return self._inner.test_get_value(ping_name)

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.TimingDistributionMetricType.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, timer_id: glean._uniffi.TimerId) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Abort a previous <code>start</code> call. No error is recorded if no <code>start</code> was called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timer_id</code></strong></dt>
<dd>The timer id associated with this timing. This allows for
concurrent timing of events associated with different ids to
the same timing distribution metric.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, timer_id: TimerId) -&gt; None:
    &#34;&#34;&#34;
    Abort a previous `start` call. No error is recorded if no `start` was called.

    Args:
        timer_id: The timer id associated with this timing. This allows for
            concurrent timing of events associated with different ids to
            the same timing distribution metric.
    &#34;&#34;&#34;
    self._inner.cancel(timer_id)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.measure"><code class="name flex">
<span>def <span class="ident">measure</span></span>(<span>self) ‑> _TimingDistributionContextManager</span>
</code></dt>
<dd>
<div class="desc"><p>Provides a context manager for measuring the time it takes to execute
snippets of code in a <code>with</code> statement.</p>
<p>If the contents of the <code>with</code> statement raise an exception, the timing
is not recorded.</p>
<h2 id="usage">Usage</h2>
<p>with metrics.perf.timer.measure():
# &hellip; do something that takes time &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def measure(self) -&gt; &#34;_TimingDistributionContextManager&#34;:
    &#34;&#34;&#34;
    Provides a context manager for measuring the time it takes to execute
    snippets of code in a `with` statement.

    If the contents of the `with` statement raise an exception, the timing
    is not recorded.

    Usage:
        with metrics.perf.timer.measure():
            # ... do something that takes time ...
    &#34;&#34;&#34;
    return self._TimingDistributionContextManager(self)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> glean._uniffi.TimerId</span>
</code></dt>
<dd>
<div class="desc"><p>Start tracking time for the provided metric.
Multiple timers can run simultaneously.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>timer_id</code></dt>
<dd>The object to associate with this timing.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; TimerId:
    &#34;&#34;&#34;
    Start tracking time for the provided metric.
    Multiple timers can run simultaneously.

    Returns:
        timer_id: The object to associate with this timing.
    &#34;&#34;&#34;
    return self._inner.start()</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.stop_and_accumulate"><code class="name flex">
<span>def <span class="ident">stop_and_accumulate</span></span>(<span>self, timer_id: glean._uniffi.TimerId) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Stop tracking time for the provided metric and associated timer id. Add a
count to the corresponding bucket in the timing distribution.
This will record an error if no <code>start</code> was called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timer_id</code></strong></dt>
<dd>The timer id associated with this timing. This allows for
concurrent timing of events associated with different ids to
the same timespan metric.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_and_accumulate(self, timer_id: TimerId) -&gt; None:
    &#34;&#34;&#34;
    Stop tracking time for the provided metric and associated timer id. Add a
    count to the corresponding bucket in the timing distribution.
    This will record an error if no `start` was called.

    Args:
        timer_id: The timer id associated with this timing. This allows for
            concurrent timing of events associated with different ids to
            the same timespan metric.
    &#34;&#34;&#34;
    self._inner.stop_and_accumulate(timer_id)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.ErrorType) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Optional[str] = None) ‑> Optional[glean._uniffi.DistributionData]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (DistriubutionData): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(
    self, ping_name: Optional[str] = None
) -&gt; Optional[DistributionData]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (DistriubutionData): value of the stored metric.
    &#34;&#34;&#34;
    return self._inner.test_get_value(ping_name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.UrlMetricType"><code class="flex name class">
<span>class <span class="ident">UrlMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.CommonMetricData)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording URL metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The url API only exposes the <code><a title="glean.metrics.UrlMetricType.set" href="#glean.metrics.UrlMetricType.set">UrlMetricType.set()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.
See <a href="https://mozilla.github.io/glean/book/reference/metrics/url.html#limits">https://mozilla.github.io/glean/book/reference/metrics/url.html#limits</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UrlMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording URL metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The url API only exposes the `UrlMetricType.set` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    See https://mozilla.github.io/glean/book/reference/metrics/url.html#limits
    &#34;&#34;&#34;

    def __init__(self, common_metric_data: CommonMetricData):
        self._inner = UrlMetric(common_metric_data)

    def set(self, value: str) -&gt; None:
        &#34;&#34;&#34;
        Set a URL value.

        Args:
            value (str): This is a user-defined URL value. If the length of
                the URL exceeds the maximum length, it will not be recorded.
        &#34;&#34;&#34;
        if value is None:
            return

        self._inner.set(value)

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
        return self._inner.test_get_value(ping_name)

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.UrlMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set a URL value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>This is a user-defined URL value. If the length of
the URL exceeds the maximum length, it will not be recorded.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: str) -&gt; None:
    &#34;&#34;&#34;
    Set a URL value.

    Args:
        value (str): This is a user-defined URL value. If the length of
            the URL exceeds the maximum length, it will not be recorded.
    &#34;&#34;&#34;
    if value is None:
        return

    self._inner.set(value)</code></pre>
</details>
</dd>
<dt id="glean.metrics.UrlMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.ErrorType) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
</dd>
<dt id="glean.metrics.UrlMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Optional[str] = None) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[str]:
    return self._inner.test_get_value(ping_name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.UuidMetricType"><code class="flex name class">
<span>class <span class="ident">UuidMetricType</span></span>
<span>(</span><span>common_metric_data: glean._uniffi.CommonMetricData)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording UUID metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The UUID API exposes the <code><a title="glean.metrics.UuidMetricType.generate_and_set" href="#glean.metrics.UuidMetricType.generate_and_set">UuidMetricType.generate_and_set()</a></code> and
<code><a title="glean.metrics.UuidMetricType.set" href="#glean.metrics.UuidMetricType.set">UuidMetricType.set()</a></code> methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UuidMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording UUID metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The UUID API exposes the `UuidMetricType.generate_and_set` and
    `UuidMetricType.set` methods.
    &#34;&#34;&#34;

    def __init__(self, common_metric_data: CommonMetricData):
        self._inner = UuidMetric(common_metric_data)

    def generate_and_set(self) -&gt; Optional[uuid.UUID]:
        &#34;&#34;&#34;
        Generate a new UUID value and set it in the metric store.
        &#34;&#34;&#34;
        id = self._inner.generate_and_set()
        return uuid.UUID(&#34;urn:uuid:&#34; + id)

    def set(self, value: Union[uuid.UUID, str]) -&gt; None:
        &#34;&#34;&#34;
        Explicitly set an existing UUID value.

        Args:
            value (uuid.UUID): A valid UUID to set the metric to.
        &#34;&#34;&#34;
        self._inner.set(str(value))

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[uuid.UUID]:
        id = self._inner.test_get_value()
        if id:
            return uuid.UUID(&#34;urn:uuid:&#34; + id)
        else:
            return None

    def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
        return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.UuidMetricType.generate_and_set"><code class="name flex">
<span>def <span class="ident">generate_and_set</span></span>(<span>self) ‑> Optional[uuid.UUID]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a new UUID value and set it in the metric store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_and_set(self) -&gt; Optional[uuid.UUID]:
    &#34;&#34;&#34;
    Generate a new UUID value and set it in the metric store.
    &#34;&#34;&#34;
    id = self._inner.generate_and_set()
    return uuid.UUID(&#34;urn:uuid:&#34; + id)</code></pre>
</details>
</dd>
<dt id="glean.metrics.UuidMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: Union[uuid.UUID, str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Explicitly set an existing UUID value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>uuid.UUID</code></dt>
<dd>A valid UUID to set the metric to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: Union[uuid.UUID, str]) -&gt; None:
    &#34;&#34;&#34;
    Explicitly set an existing UUID value.

    Args:
        value (uuid.UUID): A valid UUID to set the metric to.
    &#34;&#34;&#34;
    self._inner.set(str(value))</code></pre>
</details>
</dd>
<dt id="glean.metrics.UuidMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: glean._uniffi.ErrorType) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(self, error_type: ErrorType) -&gt; int:
    return self._inner.test_get_num_recorded_errors(error_type)</code></pre>
</details>
</dd>
<dt id="glean.metrics.UuidMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Optional[str] = None) ‑> Optional[uuid.UUID]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; Optional[uuid.UUID]:
    id = self._inner.test_get_value()
    if id:
        return uuid.UUID(&#34;urn:uuid:&#34; + id)
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="glean" href="../index.html">glean</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="glean.metrics.datetime" href="datetime.html">glean.metrics.datetime</a></code></li>
<li><code><a title="glean.metrics.event" href="event.html">glean.metrics.event</a></code></li>
<li><code><a title="glean.metrics.labeled" href="labeled.html">glean.metrics.labeled</a></code></li>
<li><code><a title="glean.metrics.ping" href="ping.html">glean.metrics.ping</a></code></li>
<li><code><a title="glean.metrics.string" href="string.html">glean.metrics.string</a></code></li>
<li><code><a title="glean.metrics.timespan" href="timespan.html">glean.metrics.timespan</a></code></li>
<li><code><a title="glean.metrics.timing_distribution" href="timing_distribution.html">glean.metrics.timing_distribution</a></code></li>
<li><code><a title="glean.metrics.url" href="url.html">glean.metrics.url</a></code></li>
<li><code><a title="glean.metrics.uuid" href="uuid.html">glean.metrics.uuid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="glean.metrics.BooleanMetric" href="#glean.metrics.BooleanMetric">BooleanMetric</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.BooleanMetric.set" href="#glean.metrics.BooleanMetric.set">set</a></code></li>
<li><code><a title="glean.metrics.BooleanMetric.test_get_num_recorded_errors" href="#glean.metrics.BooleanMetric.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.BooleanMetric.test_get_value" href="#glean.metrics.BooleanMetric.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.CommonMetricData" href="#glean.metrics.CommonMetricData">CommonMetricData</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.CounterMetric" href="#glean.metrics.CounterMetric">CounterMetric</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.CounterMetric.add" href="#glean.metrics.CounterMetric.add">add</a></code></li>
<li><code><a title="glean.metrics.CounterMetric.test_get_num_recorded_errors" href="#glean.metrics.CounterMetric.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.CounterMetric.test_get_value" href="#glean.metrics.CounterMetric.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.DatetimeMetricType" href="#glean.metrics.DatetimeMetricType">DatetimeMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.DatetimeMetricType.set" href="#glean.metrics.DatetimeMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.DatetimeMetricType.test_get_num_recorded_errors" href="#glean.metrics.DatetimeMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.DatetimeMetricType.test_get_value" href="#glean.metrics.DatetimeMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.DatetimeMetricType.test_get_value_as_str" href="#glean.metrics.DatetimeMetricType.test_get_value_as_str">test_get_value_as_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.EventExtras" href="#glean.metrics.EventExtras">EventExtras</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.EventExtras.to_ffi_extra" href="#glean.metrics.EventExtras.to_ffi_extra">to_ffi_extra</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.EventMetricType" href="#glean.metrics.EventMetricType">EventMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.EventMetricType.record" href="#glean.metrics.EventMetricType.record">record</a></code></li>
<li><code><a title="glean.metrics.EventMetricType.test_get_num_recorded_errors" href="#glean.metrics.EventMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.EventMetricType.test_get_value" href="#glean.metrics.EventMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledBooleanMetricType" href="#glean.metrics.LabeledBooleanMetricType">LabeledBooleanMetricType</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledCounterMetricType" href="#glean.metrics.LabeledCounterMetricType">LabeledCounterMetricType</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledStringMetricType" href="#glean.metrics.LabeledStringMetricType">LabeledStringMetricType</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.Lifetime" href="#glean.metrics.Lifetime">Lifetime</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.Lifetime.APPLICATION" href="#glean.metrics.Lifetime.APPLICATION">APPLICATION</a></code></li>
<li><code><a title="glean.metrics.Lifetime.PING" href="#glean.metrics.Lifetime.PING">PING</a></code></li>
<li><code><a title="glean.metrics.Lifetime.USER" href="#glean.metrics.Lifetime.USER">USER</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.MemoryDistributionMetric" href="#glean.metrics.MemoryDistributionMetric">MemoryDistributionMetric</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.MemoryDistributionMetric.accumulate" href="#glean.metrics.MemoryDistributionMetric.accumulate">accumulate</a></code></li>
<li><code><a title="glean.metrics.MemoryDistributionMetric.accumulate_samples" href="#glean.metrics.MemoryDistributionMetric.accumulate_samples">accumulate_samples</a></code></li>
<li><code><a title="glean.metrics.MemoryDistributionMetric.test_get_num_recorded_errors" href="#glean.metrics.MemoryDistributionMetric.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.MemoryDistributionMetric.test_get_value" href="#glean.metrics.MemoryDistributionMetric.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.MemoryUnit" href="#glean.metrics.MemoryUnit">MemoryUnit</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.MemoryUnit.BYTE" href="#glean.metrics.MemoryUnit.BYTE">BYTE</a></code></li>
<li><code><a title="glean.metrics.MemoryUnit.GIGABYTE" href="#glean.metrics.MemoryUnit.GIGABYTE">GIGABYTE</a></code></li>
<li><code><a title="glean.metrics.MemoryUnit.KILOBYTE" href="#glean.metrics.MemoryUnit.KILOBYTE">KILOBYTE</a></code></li>
<li><code><a title="glean.metrics.MemoryUnit.MEGABYTE" href="#glean.metrics.MemoryUnit.MEGABYTE">MEGABYTE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.PingType" href="#glean.metrics.PingType">PingType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.PingType.submit" href="#glean.metrics.PingType.submit">submit</a></code></li>
<li><code><a title="glean.metrics.PingType.test_before_next_submit" href="#glean.metrics.PingType.test_before_next_submit">test_before_next_submit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.QuantityMetric" href="#glean.metrics.QuantityMetric">QuantityMetric</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.QuantityMetric.set" href="#glean.metrics.QuantityMetric.set">set</a></code></li>
<li><code><a title="glean.metrics.QuantityMetric.test_get_num_recorded_errors" href="#glean.metrics.QuantityMetric.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.QuantityMetric.test_get_value" href="#glean.metrics.QuantityMetric.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.RecordedEvent" href="#glean.metrics.RecordedEvent">RecordedEvent</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.RecordedExperiment" href="#glean.metrics.RecordedExperiment">RecordedExperiment</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.StringListMetric" href="#glean.metrics.StringListMetric">StringListMetric</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.StringListMetric.add" href="#glean.metrics.StringListMetric.add">add</a></code></li>
<li><code><a title="glean.metrics.StringListMetric.set" href="#glean.metrics.StringListMetric.set">set</a></code></li>
<li><code><a title="glean.metrics.StringListMetric.test_get_num_recorded_errors" href="#glean.metrics.StringListMetric.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.StringListMetric.test_get_value" href="#glean.metrics.StringListMetric.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.StringMetricType" href="#glean.metrics.StringMetricType">StringMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.StringMetricType.set" href="#glean.metrics.StringMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.StringMetricType.test_get_num_recorded_errors" href="#glean.metrics.StringMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.StringMetricType.test_get_value" href="#glean.metrics.StringMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.TimeUnit" href="#glean.metrics.TimeUnit">TimeUnit</a></code></h4>
<ul class="two-column">
<li><code><a title="glean.metrics.TimeUnit.DAY" href="#glean.metrics.TimeUnit.DAY">DAY</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.HOUR" href="#glean.metrics.TimeUnit.HOUR">HOUR</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.MICROSECOND" href="#glean.metrics.TimeUnit.MICROSECOND">MICROSECOND</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.MILLISECOND" href="#glean.metrics.TimeUnit.MILLISECOND">MILLISECOND</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.MINUTE" href="#glean.metrics.TimeUnit.MINUTE">MINUTE</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.NANOSECOND" href="#glean.metrics.TimeUnit.NANOSECOND">NANOSECOND</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.SECOND" href="#glean.metrics.TimeUnit.SECOND">SECOND</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.TimerId" href="#glean.metrics.TimerId">TimerId</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.TimespanMetricType" href="#glean.metrics.TimespanMetricType">TimespanMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.TimespanMetricType.cancel" href="#glean.metrics.TimespanMetricType.cancel">cancel</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.measure" href="#glean.metrics.TimespanMetricType.measure">measure</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.set_raw_nanos" href="#glean.metrics.TimespanMetricType.set_raw_nanos">set_raw_nanos</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.start" href="#glean.metrics.TimespanMetricType.start">start</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.stop" href="#glean.metrics.TimespanMetricType.stop">stop</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.test_get_num_recorded_errors" href="#glean.metrics.TimespanMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.test_get_value" href="#glean.metrics.TimespanMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.TimingDistributionMetricType" href="#glean.metrics.TimingDistributionMetricType">TimingDistributionMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.TimingDistributionMetricType.cancel" href="#glean.metrics.TimingDistributionMetricType.cancel">cancel</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.measure" href="#glean.metrics.TimingDistributionMetricType.measure">measure</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.start" href="#glean.metrics.TimingDistributionMetricType.start">start</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.stop_and_accumulate" href="#glean.metrics.TimingDistributionMetricType.stop_and_accumulate">stop_and_accumulate</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.test_get_num_recorded_errors" href="#glean.metrics.TimingDistributionMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.test_get_value" href="#glean.metrics.TimingDistributionMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.UrlMetricType" href="#glean.metrics.UrlMetricType">UrlMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.UrlMetricType.set" href="#glean.metrics.UrlMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.UrlMetricType.test_get_num_recorded_errors" href="#glean.metrics.UrlMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.UrlMetricType.test_get_value" href="#glean.metrics.UrlMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.UuidMetricType" href="#glean.metrics.UuidMetricType">UuidMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.UuidMetricType.generate_and_set" href="#glean.metrics.UuidMetricType.generate_and_set">generate_and_set</a></code></li>
<li><code><a title="glean.metrics.UuidMetricType.set" href="#glean.metrics.UuidMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.UuidMetricType.test_get_num_recorded_errors" href="#glean.metrics.UuidMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.UuidMetricType.test_get_value" href="#glean.metrics.UuidMetricType.test_get_value">test_get_value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>